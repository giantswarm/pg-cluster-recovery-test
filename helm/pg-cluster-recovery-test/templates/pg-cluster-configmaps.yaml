{{- $global := .Values }}
{{- range $cluster := .Values.pgClusters.clusters }}
{{- with $global }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ $cluster.name }}
  namespace: {{ $cluster.namespace }}
data:
  pg-recovery-cluster.yaml: |
    apiVersion: postgresql.cnpg.io/v1
    kind: Cluster
    metadata:
      labels:
        {{ tpl (include "labels.common" $) . | nindent 8 }}
      name: {{ $cluster.name }}
      namespace: {{ $cluster.namespace }}
    spec:
      instances: {{ $cluster.instances }}
      imageName: {{ $global.registry }}/{{ $global.pgClusters.image.name }}:{{ $global.pgClusters.image.tag }}
      postgresql:
        parameters:
          # Maximum size of the WAL
          max_wal_size: '512MB'
          # Specifies the minimum size of past WAL files kept in the pg_wal directory
          wal_keep_size: '128MB'
          # Specify the maximum size of WAL files that replication slot
          max_slot_wal_keep_size: '128MB'
      storage:
        size: {{ $cluster.storageSize }}
      bootstrap:
        recovery:
          source: {{ $cluster.backupCluster.name }}
      externalClusters:
      - name: {{ $cluster.backupCluster.name }}
        barmanObjectStore:
          {{- if (eq $global.provider "capa") }}
          destinationPath: {{ $cluster.backupCluster.destinationPath }}
          s3Credentials:
            inheritFromIAMRole: true
          {{- end }}
          {{- if or (eq $global.provider "capz") (and (eq .customer "giantswarm") (or (eq $global.provider "vsphere") (eq $global.provider "cloud-director"))) }}
          destinationPath: {{ $cluster.backupCluster.destinationPath }}
          azureCredentials:
            storageAccount:
              name: {{ $cluster.backupCluster.azureSecret.secretName }}
              key: {{ $cluster.backupCluster.azureSecret.name }}
            storageKey:
              name: {{ $cluster.backupCluster.azureSecret.name }}
              key: {{ $cluster.backupCluster.azureSecret.key }}
          {{- end }}
          wal:
            maxParallel: 8
      {{- end }}
      {{- if (eq $global.provider "capa") }}
      serviceAccountTemplate:
        metadata:
          annotations:
            {{ toYaml $cluster.serviceAccount.annotations | nindent 8}}
      {{- end }}
  test-script.sh: |
    #!/bin/sh

    # Make sure that a posgresql cluster with the same name is not already running
    if kubectl get cluster.postgresql.cnpg.io {{ $cluster.name }} -n {{ $cluster.namespace }}; then
      echo "A cluster with the name {{ $cluster.name }} already exists in namespace {{ $cluster.namespace }}. Please delete it before running the recovery test."
      
      exit 1
    fi
    
    # create the recovery test cluster
    kubectl apply -f /etc/config/pg-recovery-cluster.yaml

    # Wait for the cluster to be ready
    sleep 600

    echo "Running recovery test for cluster {{ $cluster.name }}"

    # Execute tests until either those are successful or the timeout is reached
    while [ $SECONDS -lt $TEST_TIMEOUT ]; do
      # Check if the cluster is ready
      if [[ "${kubectl get clusters.postgresql.cnpg.io -n {{ $cluster.namespace }} {{ $cluster.name }} -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}'}" == "True"]]; then
        echo "{{ $cluster.name }} successfully entered the 'Ready' state"

        # If the postgresql cluster is ready, check if all the generated pods are in 'Ready' state
        if [[ "${kubectl get pods -n {{ $cluster.namespace }} -l cnpg.io/cluster={{ $cluster.name }} -o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}' | grep True | wc -w}" -eq $cluster.instances ]]; then
          echo "All pods for cluster {{ $cluster.name }} are in 'Ready' state. Recovery test successful."
          echo "Deleteting the recovery test cluster {{ $cluster.name }}"

          # If the postgresql cluster's pods are ready, delete the cluster and end the test
          kubectl delete cluster.postgresql.cnpg.io {{ $cluster.name }} -n {{ $cluster.namespace }}

          exit 0
        fi
      fi
      
      echo "Waiting for cluster {{ $cluster.name }} to be ready since $SECONDS seconds..."
      sleep 300
    done

    # If the timeout is reached, end the test without deleting the cluster to allow further investigation
    echo "Recovery test completed"
{{- end }}
